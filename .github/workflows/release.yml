name: Release

on:
  # push:
  #   branches:
  #     - main
  #     - 'feature/**'
  #     - 'fix/**'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (only for main branch)'
        required: false
        default: 'major'
        type: choice
        options:
          - major
  # Add pull_request trigger for testing on feature/fix branches
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
    
permissions:
  contents: write
  pull-requests: read  # Added for PR triggers

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request' && github.head_ref || github.ref }}

      - name: Build Accelerator Bicep
        run: |
          echo "‚úÖ Building Bicep templates..."
          mkdir -p ./artifacts
          
          # Check if Azure CLI is available
          if command -v az &> /dev/null; then
            az bicep build --file ./infra/main.bicep --outdir ./artifacts
            echo "‚úÖ Bicep build completed"
          else
            echo "‚ö†Ô∏è Azure CLI not available, creating placeholder artifacts"
            echo "Bicep build would be executed here" > ./artifacts/placeholder.txt
          fi

  generate_release:
    runs-on: ubuntu-latest
    needs: build
    outputs:
      new_version: ${{ steps.next_version.outputs.new_version }}
      release_type: ${{ steps.determine_release_type.outputs.release_type }}
      previous_tag: ${{ steps.get_tag.outputs.tag }}
      should_release: ${{ steps.determine_release_type.outputs.should_release }}
      should_publish: ${{ steps.determine_release_type.outputs.should_publish }}
      branch_name: ${{ steps.branch_info.outputs.branch_name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Ensure we get the correct branch for PRs
          ref: ${{ github.event_name == 'pull_request' && github.head_ref || github.ref }}

      - name: Setup Git identity
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

      - name: Debug trigger information
        run: |
          echo "üêõ Debug Information:"
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Head ref: ${{ github.head_ref }}"
          echo "Base ref: ${{ github.base_ref }}"
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          echo "SHA: ${{ github.sha }}"

      - name: Get branch information
        id: branch_info
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            branch_name="${{ github.ref_name }}"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            branch_name="${{ github.head_ref }}"
          else
            branch_name="${{ github.ref_name }}"
          fi
          
          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT
          echo "‚úÖ Current branch: $branch_name"

      - name: Get latest tag
        id: get_tag
        run: |
          # Fetch all tags
          git fetch --tags --force
          tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "tag=$tag" >> $GITHUB_OUTPUT
          echo "‚úÖ Latest tag: $tag"

      - name: Determine release type and strategy
        id: determine_release_type
        run: |
          branch_name="${{ steps.branch_info.outputs.branch_name }}"
          should_release="true"
          should_publish="true"
          
          echo "üîç Analyzing branch: $branch_name"
          
          # For PR events, only create pre-releases
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "üìã Pull Request detected - Creating pre-release"
            should_publish="false"
          fi
          
          if [[ "$branch_name" == "main" ]]; then
            # Main branch: conditional major increment with new rule
            release_type="main"
            should_publish="true"
            echo "‚úÖ Main branch detected - Conditional major release strategy with new rule"
            
          elif [[ "$branch_name" == feature/* ]]; then
            # Feature branch: patch increment with overflow logic
            release_type="feature"
            should_publish="false"
            echo "‚úÖ Feature branch detected - Patch increment with overflow strategy (no release publication)"
            
          elif [[ "$branch_name" == fix/* ]]; then
            # Fix branch: minor increment with overflow logic
            release_type="fix"
            should_publish="false"
            echo "‚úÖ Fix branch detected - Minor increment with overflow strategy (no release publication)"
            
          else
            echo "‚ö†Ô∏è Unsupported branch pattern: $branch_name"
            echo "Only main, feature/*, and fix/* branches are supported for releases"
            should_release="false"
            should_publish="false"
            release_type="none"
          fi
          
          echo "release_type=$release_type" >> $GITHUB_OUTPUT
          echo "should_release=$should_release" >> $GITHUB_OUTPUT
          echo "should_publish=$should_publish" >> $GITHUB_OUTPUT
          
          echo "üìã Release Summary:"
          echo "  - Will create tag and version: $should_release"
          echo "  - Will publish GitHub release: $should_publish"

      - name: Count commits since last tag
        id: count_commits
        if: steps.determine_release_type.outputs.should_release == 'true'
        run: |
          last_tag="${{ steps.get_tag.outputs.tag }}"
          branch_name="${{ steps.branch_info.outputs.branch_name }}"
          
          echo "üîç Counting commits for branch: $branch_name"
          echo "üè∑Ô∏è Last tag: $last_tag"
          
          if [ "$last_tag" = "v0.0.0" ]; then
            # No previous tags, count all commits
            if [[ "$branch_name" == "main" ]]; then
              commit_count=$(git rev-list --count HEAD)
            else
              # For feature/fix branches, count commits in this branch only
              merge_base=$(git merge-base HEAD origin/main 2>/dev/null || git merge-base HEAD main 2>/dev/null || echo "")
              if [ -n "$merge_base" ]; then
                commit_count=$(git rev-list --count ${merge_base}..HEAD)
              else
                commit_count=$(git rev-list --count HEAD)
              fi
            fi
          else
            # Count commits since last tag
            if [[ "$branch_name" == "main" ]]; then
              commit_count=$(git rev-list --count ${last_tag}..HEAD)
            else
              # For feature/fix branches, count commits since branch diverged from main
              merge_base=$(git merge-base HEAD origin/main 2>/dev/null || git merge-base HEAD main 2>/dev/null || echo "")
              if [ -n "$merge_base" ]; then
                commit_count=$(git rev-list --count ${merge_base}..HEAD)
              else
                commit_count=$(git rev-list --count ${last_tag}..HEAD)
              fi
            fi
          fi
          
          # Ensure minimum commit count of 1
          if [ "$commit_count" -eq 0 ]; then
            commit_count=1
          fi
          
          echo "commit_count=$commit_count" >> $GITHUB_OUTPUT
          echo "‚úÖ Commits to include: $commit_count"

      - name: Calculate next version
        id: next_version
        if: steps.determine_release_type.outputs.should_release == 'true'
        run: |
          current_version="${{ steps.get_tag.outputs.tag }}"
          release_type="${{ steps.determine_release_type.outputs.release_type }}"
          commit_count="${{ steps.count_commits.outputs.commit_count }}"
          branch_name="${{ steps.branch_info.outputs.branch_name }}"
          
          # Remove 'v' prefix if present
          current_version=${current_version#v}
          IFS='.' read -r major minor patch <<< "$current_version"
          
          echo "üìä Current version: v$major.$minor.$patch"
          echo "üìä Release type: $release_type"
          echo "üìä Commit count: $commit_count"
          
          case "$release_type" in
            main)
              # NEW RULE: Main branch conditional major increment
              # Only increase major if minor and patch are both 0
              # Otherwise, keep major and update minor/patch accordingly
              
              echo "üéØ Main branch: Applying new conditional major increment rule"
              echo "üìã Current state: major=$major, minor=$minor, patch=$patch"
              
              if [ "$minor" -eq 0 ] && [ "$patch" -eq 0 ]; then
                # Rule condition met: minor=0 AND patch=0 -> increment major
                major=$((major + 1))
                minor=0
                patch=0
                echo "‚úÖ Rule condition met (minor=0 AND patch=0): Incrementing major to $major"
              else
                # Rule condition NOT met: keep major, update minor/patch
                echo "‚ö†Ô∏è Rule condition NOT met (minor‚â†0 OR patch‚â†0): Keeping major=$major"
                
                # Increment patch first, then handle overflow
                new_patch=$((patch + 1))
                
                if [ $new_patch -gt 99 ]; then
                  # Patch overflow: reset patch to 0 and increment minor
                  patch=0
                  minor=$((minor + 1))
                  
                  # Check if minor also overflows
                  if [ $minor -gt 99 ]; then
                    # Minor overflow: reset minor to 0 and increment major
                    minor=0
                    major=$((major + 1))
                    echo "‚ö†Ô∏è Minor overflow detected: Incrementing major to $major, resetting minor to 0"
                  fi
                  
                  echo "‚ö†Ô∏è Patch overflow detected: Incrementing minor to $minor, resetting patch to 0"
                else
                  patch=$new_patch
                  echo "‚úÖ Incrementing patch to $patch"
                fi
              fi
              
              version_suffix=""
              echo "üéØ Main branch result: major=$major, minor=$minor, patch=$patch"
              ;;
            feature)
              # Feature branch: patch increment with overflow logic
              # patch: if previous patch + commits > 99, then patch = 0 and minor += 1
              new_patch=$((patch + commit_count))
              
              echo "üî¢ Calculating patch overflow: $patch + $commit_count = $new_patch"
              
              if [ $new_patch -gt 99 ]; then
                # Overflow: reset patch to 0 and increment minor
                patch=0
                minor=$((minor + 1))
                
                # Check if minor also overflows
                if [ $minor -gt 99 ]; then
                  minor=0
                  major=$((major + 1))
                  echo "‚ö†Ô∏è Minor overflow detected: Incrementing major to $major, resetting minor to 0"
                fi
                
                echo "‚ö†Ô∏è Patch overflow detected: Incrementing minor to $minor, resetting patch to 0"
              else
                patch=$new_patch
                echo "‚úÖ No overflow: Setting patch to $patch"
              fi
              
              # Clean branch name for version suffix
              clean_branch_name=$(echo "${branch_name#feature/}" | sed 's/[^a-zA-Z0-9]/-/g')
              version_suffix="-feature.$clean_branch_name"
              ;;
            fix)
              # Fix branch: minor increment with overflow logic
              # minor: if previous minor + commits > 99, then minor = 0 and major += 1
              new_minor=$((minor + commit_count))
              
              echo "üî¢ Calculating minor overflow: $minor + $commit_count = $new_minor"
              
              if [ $new_minor -gt 99 ]; then
                # Overflow: reset minor to 0 and increment major
                minor=0
                major=$((major + 1))
                echo "‚ö†Ô∏è Minor overflow detected: Incrementing major to $major, resetting minor to 0"
              else
                minor=$new_minor
                echo "‚úÖ No overflow: Setting minor to $minor"
              fi
              
              # Clean branch name for version suffix
              clean_branch_name=$(echo "${branch_name#fix/}" | sed 's/[^a-zA-Z0-9]/-/g')
              version_suffix="-fix.$clean_branch_name"
              ;;
            *)
              echo "‚ùå Invalid release type: $release_type"
              exit 1
              ;;
          esac
          
          # Add PR suffix if this is a pull request
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            version_suffix="${version_suffix}-pr${{ github.event.number }}"
          fi
          
          new_version="v$major.$minor.$patch$version_suffix"
          echo "‚úÖ Next version: $new_version"
          echo "üìä Final version breakdown: major=$major, minor=$minor, patch=$patch"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT

  create_tag:
    runs-on: ubuntu-latest
    needs: generate_release
    if: needs.generate_release.outputs.should_release == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'pull_request' && github.head_ref || github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git identity
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

      - name: Create and push tag
        run: |
          tag_name="${{ needs.generate_release.outputs.new_version }}"
          branch_name="${{ needs.generate_release.outputs.branch_name }}"
          should_publish="${{ needs.generate_release.outputs.should_publish }}"
          
          echo "üè∑Ô∏è Creating tag: $tag_name"
          echo "üîÄ For branch: $branch_name"
          echo "üìã Will publish release: $should_publish"
          
          # Create annotated tag
          if [[ "$branch_name" == "main" ]]; then
            git tag -a "$tag_name" -m "Release $tag_name from main branch"
          else
            git tag -a "$tag_name" -m "Development tag $tag_name from $branch_name branch (no release)"
          fi
          
          # Push the tag
          git push origin "$tag_name"
          echo "‚úÖ Tag $tag_name created and pushed successfully"
  
  upload_artifacts:
    runs-on: ubuntu-latest
    needs: [generate_release, create_tag]
    if: needs.generate_release.outputs.should_release == 'true'
    steps:

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request' && github.head_ref || github.ref }}

      - name: Build Accelerator Bicep
        run: |
          echo "‚úÖ Building Bicep templates..."
          mkdir -p ./artifacts
          
          # Check if Azure CLI is available
          if command -v az &> /dev/null; then
            az bicep build --file ./infra/main.bicep --outdir ./artifacts
            echo "‚úÖ Bicep build completed"
          else
            echo "‚ö†Ô∏è Azure CLI not available, creating placeholder artifacts"
            echo "Bicep build would be executed here" > ./artifacts/placeholder.txt
          fi

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ needs.generate_release.outputs.new_version }}
          path: ./artifacts
          compression-level: 6
          overwrite: true
          if-no-files-found: warn
          retention-days: 7

      - name: Artifact Summary
        run: |
          branch_name="${{ needs.generate_release.outputs.branch_name }}"
          version="${{ needs.generate_release.outputs.new_version }}"
          should_publish="${{ needs.generate_release.outputs.should_publish }}"
          
          echo "üì¶ Artifacts Summary:"
          echo "  - Version: $version"
          echo "  - Branch: $branch_name"
          echo "  - Tag created: ‚úÖ"
          echo "  - Artifacts uploaded: ‚úÖ"
          echo "  - GitHub release will be published: $should_publish"
          
          if [[ "$should_publish" == "false" ]]; then
            echo ""
            echo "‚ÑπÔ∏è  This is a development build from a non-main branch."
            echo "   Tag and artifacts are created for tracking, but no GitHub release is published."
          fi

  publish_release:
    runs-on: ubuntu-latest
    needs: [generate_release, create_tag, upload_artifacts]
    if: needs.generate_release.outputs.should_publish == 'true'
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: artifacts-${{ needs.generate_release.outputs.new_version }}
          path: ./artifacts

      - name: Create Git Tag and GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.generate_release.outputs.new_version }}
          name: Release ${{ needs.generate_release.outputs.new_version }}
          body: |
            üåü **Branch-Based Release Strategy with Conditional Major Increment**
            
            üîÄ **Branch**: `${{ needs.generate_release.outputs.branch_name }}`
            üè∑Ô∏è **Version**: `${{ needs.generate_release.outputs.new_version }}`
            üì¶ **Previous Version**: `${{ needs.generate_release.outputs.previous_tag }}`
            üöÄ **Release Type**: `${{ needs.generate_release.outputs.release_type }}`
            ü§ñ **Trigger**: ${{ github.event_name == 'workflow_dispatch' && 'Manual' || github.event_name == 'pull_request' && 'Pull Request' || 'Push' }}
            üìù **Commit**: `${{ github.sha }}`
            
            ## Release Strategy Applied
            
            ${{ needs.generate_release.outputs.release_type == 'main' && 'üéØ **Main Branch**: Conditional major increment (only if minor=0 AND patch=0, otherwise increment patch with overflow logic)' || '' }}
            ${{ needs.generate_release.outputs.release_type == 'feature' && '‚ú® **Feature Branch**: Patch increment with overflow logic (patch += commits, overflow at 99 ‚Üí minor+1)' || '' }}
            ${{ needs.generate_release.outputs.release_type == 'fix' && 'üîß **Fix Branch**: Minor increment with overflow logic (minor += commits, overflow at 99 ‚Üí major+1)' || '' }}
            
            ## Main Branch Logic (NEW RULE)
            
            - **If minor=0 AND patch=0**: Increment major ‚Üí `major+1.0.0`
            - **If minor‚â†0 OR patch‚â†0**: Keep major, increment patch ‚Üí `major.minor.(patch+1)`
            - **Overflow handling**: If patch > 99 ‚Üí `minor+1, patch=0`; if minor > 99 ‚Üí `major+1, minor=0`
            
            ## Feature/Fix Branch Overflow Logic
            
            - **Feature branches**: If `patch + commits > 99` ‚Üí `patch = 0, minor += 1`
            - **Fix branches**: If `minor + commits > 99` ‚Üí `minor = 0, major += 1`
            - **Cascading overflow**: If minor overflows during patch overflow ‚Üí `minor = 0, major += 1`
            
            ## Artifacts
            - üìÑ Bicep templates compiled to ARM templates
            - üèóÔ∏è Infrastructure deployment files
            - üìã Release metadata and documentation
          files: ./artifacts/*
          draft: false
          prerelease: false
          make_latest: true